using System;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using Discord;
using Discord.Audio;
using Discord.WebSocket;
using Microsoft.Extensions.DependencyInjection;
using VCMuteExploitDetectionBot.Configuration;
using VCMuteExploitDetectionBot.Services;

namespace VCMuteExploitDetectionBot
{
    public class Startup
    {
        public static async Task Start()
        {
            var client = new DiscordSocketClient();
            client.Log += Logger.Log;
            var configLocation = Path.Combine(Environment.CurrentDirectory, "config.yaml");

            if (!File.Exists(configLocation))
            {
                await Logger.Critical("Startup", "Config file does not exist.");

                return;
            }

            var config = await Config.DeserializeFromFile(configLocation);

            if (config is null)
            {
                await Logger.Critical("Startup", "Config could not be read. Please check that it is valid.");

                return;
            }

            if (string.IsNullOrWhiteSpace(config.BotToken) || string.IsNullOrWhiteSpace(config.ChannelID))
            {
                await Logger.Critical("Startup", "Bot Token or Channel ID are not provided, cannot continue.");
                return;
            }

            var token = config.BotToken;
            var channelID = ulong.Parse(config.ChannelID);

            await client.LoginAsync(TokenType.Bot, token);
            await client.StartAsync();

            // This is needed for... some reason, I'm pretty sure its for the client to download/cache what channels
            // it has access to. Don't know if theres any event or awaitable method I can use to make this easier.
            await Task.Delay(1000);

            if (client.GetChannel(channelID) is not SocketVoiceChannel voiceChannel)
            {
                await Logger.Critical("Startup", "Specified channel does not exist, or is not a Voice Channel.");

                return;
            }

            var audioClient = await voiceChannel.ConnectAsync();

            var audioFile = Path.Combine(Environment.CurrentDirectory, "sound.mp3");
            using var ffmpeg = CreateFFMPEGStream(audioFile);
            using var output = ffmpeg.StandardOutput.BaseStream;
            using var voiceStream = audioClient.CreatePCMStream(AudioApplication.Mixed);

            await output.CopyToAsync(voiceStream);
            await voiceStream.FlushAsync();

            await Logger.Info("Startup", "Successfully played test audio; we are now ready to receive data.");

            var serviceProvider = new ServiceCollection()
                .AddSingleton(client)
                .AddSingleton(config)
                .AddSingleton(audioClient)
                .AddSingleton(voiceChannel)
                .AddSingleton(voiceChannel.Guild)
                .AddSingleton<MuteDetectionService>()
                .AddSingleton<ExploitDetectionService>()
                .AddSingleton<ExploitPunishmentService>()
                .BuildServiceProvider();

            // Trigger our DI system by requesting our main service.
            serviceProvider.GetRequiredService<ExploitPunishmentService>();
        }

        private static Process CreateFFMPEGStream(string path) => Process.Start(new ProcessStartInfo
        {
            FileName = "ffmpeg",
            Arguments = $"-hide_banner -loglevel panic -i \"{path}\" -ac 2 -f s16le -ar 48000 pipe:1",
            UseShellExecute = false,
            RedirectStandardOutput = true,
        });
    }
}
