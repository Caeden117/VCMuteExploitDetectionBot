using DSharpPlus.Entities;
using DSharpPlus.VoiceNext;
using DSharpPlus.VoiceNext.EventArgs;
using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using VCMuteExploitDetectionBot.Configuration;

namespace VCMuteExploitDetectionBot.Services
{
    public class ExploitDetectionService
    {
        public event Action<AbuseTracker, DiscordUser> FakeMuteExploitDetected;

        public bool Enabled = false;

        private readonly MuteDetectionService muteDetection;
        private readonly int sensitivity;
        private readonly ConcurrentDictionary<ulong, AbuseTracker> exploitDetectionHits = new();

        private VoiceNextConnection connection = null;

        public ExploitDetectionService(MuteDetectionService detection, Config config)
        {
            muteDetection = detection;
            sensitivity = config.DetectionSensitivity;
        }

        public async Task Enable(DiscordChannel channel)
        {
            Enabled = true;

            if (connection != null) return;

            connection = await channel.ConnectAsync();

            connection.VoiceReceived += Client_VoiceReceived;
            connection.UserLeft += Connection_UserLeft;
        }

        public void Disable()
        {
            Enabled = false;
            connection?.Disconnect();
            connection = null;
        }

        private Task Connection_UserLeft(VoiceNextConnection sender, VoiceUserLeaveEventArgs e)
        {
            if (e.User is null) return Task.CompletedTask;
            exploitDetectionHits.TryRemove(e.User.Id, out _);
            return Task.CompletedTask;
        }

        private Task Client_VoiceReceived(VoiceNextConnection _, VoiceReceiveEventArgs e)
        {
            if (e.User is null) return Task.CompletedTask;

            var userID = e.User.Id;

            // We go by the available frames to tell if a user is speaking,
            // then check if the user is also self muted or deafened.
            if (muteDetection.CurrentVoiceStates.TryGetValue(userID, out var voiceState)
                && (voiceState.IsSelfMuted || voiceState.IsSelfDeafened))
            {

                // Because of false positives when users mute themselves while speaking,
                // we have a system that only triggers exploit punishment when the user
                // triggers the exploit detection multiple consecutive times.
                exploitDetectionHits.AddOrUpdate(userID, new AbuseTracker
                {
                    UserID = userID
                },
                (_, oldValue) =>
                {
                    oldValue.Increment();
                    return oldValue;
                });

                var activeTrackedUser = exploitDetectionHits[userID];

                if (activeTrackedUser.ConsecutiveHits >= sensitivity && !activeTrackedUser.IsFlagged)
                {
                    FakeMuteExploitDetected?.Invoke(activeTrackedUser, e.User);
                    activeTrackedUser.IsFlagged = true;
                }
            }
            // No suspicious activity, reset our counter.
            else if (exploitDetectionHits.TryGetValue(userID, out var activeTrackedUser))
            {
                activeTrackedUser.Decrement();
            }

            return Task.CompletedTask;
        }
    }

    public class AbuseTracker
    {
        public ulong UserID;
        public bool IsFlagged;
        public int ConsecutiveHits;

        public void Increment() => Interlocked.Increment(ref ConsecutiveHits);

        public void Decrement()
        {
            if (ConsecutiveHits > 0) Interlocked.Decrement(ref ConsecutiveHits);
            if (ConsecutiveHits == 0) IsFlagged = false;
        }
    }
}
