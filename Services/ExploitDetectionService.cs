using DSharpPlus.Entities;
using DSharpPlus.VoiceNext;
using DSharpPlus.VoiceNext.EventArgs;
using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using VCMuteExploitDetectionBot.Configuration;

namespace VCMuteExploitDetectionBot.Services
{
    public class ExploitDetectionService
    {
        public event Action<AbuseTracker, DiscordUser> FakeMuteExploitDetected;

        public bool Enabled = false;

        private readonly MuteDetectionService muteDetection;
        private readonly float threshold;
        private readonly ConcurrentDictionary<ulong, AbuseTracker> exploitDetectionHits = new();
        private readonly ConcurrentDictionary<ulong, DateTime> lastReceivedAudioPacket = new();

        private VoiceNextConnection connection = null;

        public ExploitDetectionService(MuteDetectionService detection, Config config)
        {
            muteDetection = detection;
            threshold = config.TimeThreshold;
        }

        public async Task Enable(DiscordChannel channel)
        {
            Enabled = true;

            if (connection != null) return;

            connection = await channel.ConnectAsync();

            connection.VoiceReceived += Client_VoiceReceived;
            connection.UserLeft += Connection_UserLeft;
        }

        public void Disable()
        {
            Enabled = false;
            connection?.Disconnect();
            connection = null;
        }

        private Task Connection_UserLeft(VoiceNextConnection sender, VoiceUserLeaveEventArgs e)
        {
            if (e.User is null) return Task.CompletedTask;
            exploitDetectionHits.TryRemove(e.User.Id, out _);
            return Task.CompletedTask;
        }

        private Task Client_VoiceReceived(VoiceNextConnection __, VoiceReceiveEventArgs e)
        {
            if (e.User is null) return Task.CompletedTask;

            var userID = e.User.Id;

            // We check the MuteDetectionService to see if we've received audio data
            // while the user is muted or deafened.
            if (muteDetection.CurrentVoiceStates.TryGetValue(userID, out var voiceState)
                && (voiceState.IsSelfMuted || voiceState.IsSelfDeafened)
                // DISCORD MOMENT: Audio from cameras are still received while they're muted. WTF DISCORD!?!??!?!?!
                && !voiceState.IsSelfVideo)
            {

                // Because of false positives when users mute themselves while speaking,
                // we only trigger if the user was detected multiple consecutive times.
                var trackedUser = exploitDetectionHits.GetOrAdd(userID, new AbuseTracker(userID));

                // Resets if the time between now and the user's last received audio packet was larger than
                // half the threshold. We will treat this as a legitimate mute/unmute, and will reset the clock.
                // This should hopefully stop more false positives.
                if (lastReceivedAudioPacket.TryGetValue(userID, out var lastTimestamp) &&
                    (DateTime.Now - lastTimestamp).TotalSeconds >= (threshold / 2f))
                {
                    Logger.Info("Exploit",
                        $"The time between {userID}'s audio data exceeded half the threshold; resetting...");
                    trackedUser.Reset();                    
                }

                // Cache this timestamp for later use.
                lastReceivedAudioPacket.AddOrUpdate(userID, DateTime.Now, (_, _) => DateTime.Now);

                if (trackedUser.FirstHit is null) trackedUser.FirstHit = DateTime.Now;

                if ((DateTime.Now - trackedUser.FirstHit)?.TotalSeconds >= threshold && !trackedUser.IsFlagged)
                {
                    FakeMuteExploitDetected?.Invoke(trackedUser, e.User);
                    trackedUser.IsFlagged = true;
                }
            }
            // No suspicious activity, reset our counter.
            else
            {
                exploitDetectionHits.TryRemove(userID, out _);
            }

            return Task.CompletedTask;
        }
    }

    public class AbuseTracker
    {
        public ulong UserID;
        public bool IsFlagged;
        public DateTime? FirstHit = null;

        public AbuseTracker(ulong userID) => UserID = userID;

        public void Reset()
        {
            IsFlagged = false;
            FirstHit = null;
        }
    }
}
