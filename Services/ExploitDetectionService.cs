using Discord;
using Discord.Audio;
using System;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using VCMuteExploitDetectionBot.Configuration;

namespace VCMuteExploitDetectionBot.Services
{
    public class ExploitDetectionService
    {
        public event Action<ulong> FakeMuteExploitDetected;

        private readonly IAudioClient audioClient;
        private readonly MuteDetectionService muteDetection;
        private readonly Config config;
        private readonly int sensitivity;

        private readonly ConcurrentDictionary<ulong, int> exploitDetectionHits = new();

        public ExploitDetectionService(IAudioClient client, MuteDetectionService detection, Config config)
        {
            this.config = config;
            audioClient = client;
            muteDetection = detection;
            sensitivity = config.DetectionSensitivity;

            new Task(DetectLoop).Start();
        }

        /*
         * Yeah, this is one giant workaround.
         * 
         * Discord exposes a "SpeakingUpdated" event in their API, which would pretty much make this obsolete. BUT!
         * It only triggers once per user, the first time they start speaking.
         * Not every time the user starts/stops speaking.
         * 
         * Discord, what the fuck.
         */
        private async void DetectLoop()
        {
            while (true)
            {
                foreach (var kvp in audioClient.GetStreams())
                {
                    var userID = kvp.Key;
                    var userStream = kvp.Value;

                    // We go by the available frames to tell if a user is speaking,
                    // then check if the user is also self muted or deafened.
                    if (userStream.AvailableFrames > 0
                        && muteDetection.CurrentVoiceStates.TryGetValue(userID, out var voiceState)
                        && (voiceState.IsSelfMuted || voiceState.IsSelfDeafened))
                    {

                        // Because of false positives when users mute themselves while speaking,
                        // we have a system that only triggers exploit punishment when the user
                        // triggers the exploit detection multiple consecutive times.
                        exploitDetectionHits.AddOrUpdate(userID, 1, (_, oldValue) => ++oldValue);

                        exploitDetectionHits.TryGetValue(userID, out int hits);

                        await Logger.Debug("Exploit", $"{userID} potentially using exploit. ({hits} / {sensitivity})");

                        if (hits >= sensitivity)
                        {
                            // The user is utilizing an exploit to lie about their self mute/deafened state.
                            // Time to take action.
                            await Logger.Warning("Exploit", $"Detected {userID} using a voice chat exploit.");

                            FakeMuteExploitDetected?.Invoke(userID);
                        }
                    }
                    else
                    {
                        // No suspicious activity, reset our counter.
                        exploitDetectionHits.AddOrUpdate(userID, 0, (_, _) => 0);
                    }

                    while (userStream.AvailableFrames > 0)
                    {
                        await userStream.ReadFrameAsync(CancellationToken.None);
                    }
                }

                await Task.Delay(config.CheckFrequency);
            }
        }
    }
}
